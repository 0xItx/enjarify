// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package main

import (
	"archive/zip"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"enjarify-go/dex"
	"enjarify-go/jvm"
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func Read(name string) string {
	data, err := ioutil.ReadFile(name)
	check(err)
	return string(data)
}

func Write(name string, data string) {
	check(ioutil.WriteFile(name, []byte(data), os.ModePerm))
}

func translate(opts jvm.Options, dexs ...string) [][3]string {
	results := [][3]string{}

	for _, data := range dexs {
		dex := dex.Parse(data)
		for _, cls := range dex.Classes {
			unicode_name := Decode(cls.Name) + ".class"
			result := [3]string{unicode_name, "", ""}

			if class_data, err := jvm.ToClassFile(cls, opts); err == nil {
				result[1] = class_data
			} else {
				result[2] = err.Error()
			}
			results = append(results, result)

			if len(results)%1000 == 0 {
				fmt.Printf("%d classes processed\n", len(results))
			}
		}
	}
	return results
}

func writeToJar(fname string, classes [][2]string) {
	file, err := os.Create(fname)
	check(err)
	defer file.Close()

	w := zip.NewWriter(file)
	defer w.Close()
	for i := range classes {
		f, err := w.Create(classes[i][0])
		check(err)
		_, err = f.Write([]byte(classes[i][1]))
		check(err)
	}
}

func readDexes(apkname string) (res []string) {
	r, err := zip.OpenReader(apkname)
	check(err)
	defer r.Close()

	for _, f := range r.File {
		if strings.HasPrefix(f.Name, "classes") && strings.HasSuffix(f.Name, ".dex") {
			rc, err := f.Open()
			check(err)
			data, err := ioutil.ReadAll(rc)
			check(err)
			res = append(res, string(data))
			rc.Close()
		}
	}
	return
}

func main() {
	pout := flag.String("o", "", "Output .jar file. Default is [input-filename]-enjarify.jar.")
	pforce := flag.Bool("f", false, "Force overwrite. If output file already exists, this option is required to overwrite.")
	pfast := flag.Bool("fast", false, "Speed up translation at the expense of generated bytecode being less readable.")
	ptests := flag.Bool("runtests", false, "")
	phash := flag.Bool("hashtests", false, "")
	flag.Parse()
	inputfile := flag.Arg(0)

	if *ptests {
		runTests()
		return
	} else if *phash {
		hashTests()
		return
	}

	if inputfile == "" {
		fmt.Printf("Error, no input filename passed.\n")
		return
	}

	dexs := []string{}
	if strings.HasSuffix(strings.ToLower(inputfile), ".apk") {
		dexs = readDexes(inputfile)
	} else {
		dexs = []string{Read(inputfile)}
	}

	outname := *pout
	if outname == "" {
		s := inputfile[strings.LastIndex(inputfile, "/")+1:]
		s = s[:strings.LastIndex(s, ".")]
		outname = s + "-enjarify.jar"
	}

	mode := os.O_RDWR | os.O_CREATE
	if !*pforce {
		mode |= os.O_EXCL
	}
	outfile, err := os.OpenFile(outname, mode, os.FileMode(0666))
	if err != nil {
		fmt.Printf("Error, output file already exists and -f was not specified. To overwrite the output file, pass -f\n")
		return
	}

	opts := jvm.PRETTY
	if *pfast {
		opts = jvm.NONE
	}

	results := translate(opts, dexs...)

	classes := make([][2]string, 0, len(results))
	errors := [][2]string{}
	for i := range results {
		name := results[i][0]
		class := results[i][1]
		err := results[i][2]

		if class != "" {
			classes = append(classes, [2]string{name, class})
		} else {
			classes = append(classes, [2]string{name, err})
		}
	}

	writeToJar(outname, classes)
	outfile.Close()
	fmt.Printf("Output written to %s\n", outname)

	for i := range errors {
		fmt.Printf("%s %s\n", errors[i][0], errors[i][1])
	}
	fmt.Printf("%d classes translated successfully, %d classes had errors\n", len(classes), len(errors))
}
