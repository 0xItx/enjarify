// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#![feature(inclusive_range_syntax)]
use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::fs::OpenOptions;
use std::io::prelude::*;
use std::path::Path;
use std::panic;
use std::str;

#[macro_use]
extern crate lazy_static;

extern crate getopts;
extern crate zip;
use zip::CompressionMethod::{Deflated,Stored};

mod byteio;
mod dalvik;
mod dalvikformats;
mod dex;
mod error;
mod flags;
mod hashtests;
mod jvm;
mod mutf8;
mod runtests;
mod pack;
mod strings;
mod treelist;
mod typeinference;

use strings::*;
use jvm::optimization::options::Options;

fn read<P: AsRef<Path>>(path: P) -> BString {
    let mut data = Vec::new();
    let mut f = File::open(path).unwrap();
    f.read_to_end(&mut data).unwrap();
    data
}

fn read_jar(fname: &str) -> Vec<(String, BString)> {
    let mut items = Vec::new();
    let mut archive = zip::ZipArchive::new(File::open(fname).unwrap()).unwrap();
    for i in 0..archive.len() {
        let mut zf = archive.by_index(i).unwrap();
        let mut data = Vec::new();
        zf.read_to_end(&mut data).unwrap();
        items.push((zf.name().to_string(), data));
    }
    items.sort();
    items
}

pub fn write_to_jar(fname: &str, mut classes: HashMap<String, BString>, ordkeys: Vec<String>) {
    assert!(classes.len() == ordkeys.len());
    let mut archive = zip::ZipWriter::new(File::create(fname).unwrap());
    for unicode_name in ordkeys {
        let data = classes.remove(&unicode_name).unwrap();
        // Don't bother compressing small files
        let method = if data.len() > 10000 {Deflated} else {Stored};
        archive.start_file(unicode_name, method).unwrap();
        archive.write_all(&data).unwrap();
    }
}

fn translate(opts: Options, dexes: &[BString]) -> (HashMap<String, BString>, Vec<String>, HashMap<String, String>) {
    let mut classes = HashMap::new();
    let mut errors = HashMap::new();
    let mut ordkeys = Vec::new();

    for data in dexes.iter() {
        let dex = dex::DexFile::new(data);
        for cls in dex.parse_classes() {
            let unicode_name = mutf8::decode(cls.name).into_owned() + ".class";
            if classes.contains_key(&unicode_name) || errors.contains_key(&unicode_name) {
                println!("Warning, duplicate class name {}", unicode_name);
                continue;
            }

            panic::catch_unwind(panic::AssertUnwindSafe(|| {
                ordkeys.push(unicode_name.clone());
                classes.insert(unicode_name.clone(), jvm::writeclass::to_class_file(&cls, opts));
            })).unwrap_or_else(|err| {
                let error_string = err.downcast::<String>().map(|b| *b).or_else(|err| {
                    err.downcast::<&'static str>().map(|s| s.to_string())
                }).unwrap_or("panic with unknown type".to_string());
                errors.insert(unicode_name, error_string);
            });

            if (classes.len() + errors.len()) % 1000 == 0 {
                println!("{} classes processed", classes.len() + errors.len());
            }
        };
    }

    (classes, ordkeys, errors)
}

fn main() {
    error::set_hook();
    let args: Vec<String> = env::args().collect();

    let mut opts = getopts::Options::new();
    opts.optopt("o", "output", "Output .jar file. Default is [input-filename]-enjarify.jar.", "FILE");
    opts.optopt("i", "input", "", "FILE");
    opts.optflag("f", "force", "Force overwrite. If output file already exists, this option is required to overwrite.");
    opts.optflag("", "fast", "Speed up translation at the expense of generated bytecode being less readable.");
    opts.optflag("", "runtests", "");
    opts.optflag("", "hashtests", "");
    let opts = opts.parse(&args[1..]).unwrap();

    if opts.opt_present("runtests") { runtests::main(); return; }
    if opts.opt_present("hashtests") { hashtests::main(); return; }

    let inputfile = opts.opt_str("input").unwrap();
    let dexes: Vec<_> = if inputfile.to_lowercase().ends_with(".apk") {
        let pairs = read_jar(&inputfile);
        pairs.into_iter().filter(|&(ref name, _)| name.ends_with(".dex")).map(|(_, data)| data).collect()
    } else {
        vec![read(&inputfile)]
    };

    let outname = opts.opt_str("output").unwrap_or_else(|| {
        let ind = inputfile.rfind("/").map(|x| x+1).unwrap_or(0);
        let s = inputfile.split_at(ind).1;
        let ind = s.rfind(".").unwrap_or(s.len());
        let s = s.split_at(ind).0;
        s.to_string() + "-enjarify.jar"
    });

    {OpenOptions::new().write(true).create(true).create_new(!opts.opt_present("force")).open(&outname).expect("Error, output file already exists and -f was not specified. To overwrite the output file, pass -f\n")};

    let translate_options = if opts.opt_present("fast") { Options::none() } else { Options::pretty() };
    let (classes, ordkeys, errors) = translate(translate_options, &dexes);
    let clen = classes.len();
    write_to_jar(&outname, classes, ordkeys);

    println!("Output written to {}", outname);

    for (name, error) in errors.iter() {
        println!("{} {}", name, error);
    }
    println!("{} classes translated successfully, {} classes had errors", clen, errors.len());
}
